
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 810 – Explicit lazy imports | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0810/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 810 – Explicit lazy imports | peps.python.org'>
    <meta property="og:description" content="This PEP introduces syntax for lazy imports as an explicit language feature:">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0810/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="This PEP introduces syntax for lazy imports as an explicit language feature:">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 810</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 810 – Explicit lazy imports</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Pablo Galindo &lt;pablogsal&#32;&#97;t&#32;python.org&gt;,
Germán Méndez Bravo &lt;german.mb&#32;&#97;t&#32;gmail.com&gt;,
Thomas Wouters &lt;thomas&#32;&#97;t&#32;python.org&gt;,
Dino Viehland &lt;dinoviehland&#32;&#97;t&#32;gmail.com&gt;,
Brittany Reynoso &lt;brittanyrey&#32;&#97;t&#32;gmail.com&gt;,
Noah Kim &lt;noahbkim&#32;&#97;t&#32;gmail.com&gt;,
Tim Stumbaugh &lt;me&#32;&#97;t&#32;tjstum.com&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/104131">Discourse thread</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">02-Oct-2025</dd>
<dt class="field-even">Python-Version<span class="colon">:</span></dt>
<dd class="field-even">3.15</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/104131" title="Discourse thread">03-Oct-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#other-design-decisions">Other design decisions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#grammar">Grammar</a><ul>
<li><a class="reference internal" href="#syntax-restrictions">Syntax restrictions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#semantics">Semantics</a></li>
<li><a class="reference internal" href="#lazy-import-mechanism">Lazy import mechanism</a></li>
<li><a class="reference internal" href="#reification">Reification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a><ul>
<li><a class="reference internal" href="#bytecode-and-adaptive-specialization">Bytecode and adaptive specialization</a></li>
<li><a class="reference internal" href="#lazy-imports-filter">Lazy imports filter</a></li>
<li><a class="reference internal" href="#global-lazy-imports-control">Global lazy imports control</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#unchanged-semantics">Unchanged semantics</a></li>
<li><a class="reference internal" href="#observable-behavioral-shifts-opt-in-only">Observable behavioral shifts (opt-in only)</a></li>
<li><a class="reference internal" href="#thread-safety-and-reification">Thread-safety and reification</a></li>
<li><a class="reference internal" href="#typing-and-tools">Typing and tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#faq">FAQ</a><ul>
<li><a class="reference internal" href="#how-does-this-differ-from-the-rejected-pep-690">How does this differ from the rejected PEP 690?</a></li>
<li><a class="reference internal" href="#what-happens-when-lazy-imports-encounter-errors">What happens when lazy imports encounter errors?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-affect-modules-with-import-time-side-effects">How do lazy imports affect modules with import-time side effects?</a></li>
<li><a class="reference internal" href="#can-i-use-lazy-imports-with-from-import-statements">Can I use lazy imports with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> statements?</a></li>
<li><a class="reference internal" href="#does-lazy-from-module-import-class-load-the-entire-module-or-just-the-class">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Class</span></code> load the entire module or just the class?</a></li>
<li><a class="reference internal" href="#what-about-type-annotations-and-type-checking-imports">What about type annotations and <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> imports?</a></li>
<li><a class="reference internal" href="#what-s-the-performance-overhead-of-lazy-imports">What’s the performance overhead of lazy imports?</a></li>
<li><a class="reference internal" href="#can-i-mix-lazy-and-eager-imports-of-the-same-module">Can I mix lazy and eager imports of the same module?</a></li>
<li><a class="reference internal" href="#how-do-i-migrate-existing-code-to-use-lazy-imports">How do I migrate existing code to use lazy imports?</a></li>
<li><a class="reference internal" href="#what-about-star-imports-from-module-import">What about star imports (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>)?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-interact-with-import-hooks-and-custom-loaders">How do lazy imports interact with import hooks and custom loaders?</a></li>
<li><a class="reference internal" href="#what-happens-in-multi-threaded-environments">What happens in multi-threaded environments?</a></li>
<li><a class="reference internal" href="#can-i-force-reification-of-a-lazy-import-without-using-it">Can I force reification of a lazy import without using it?</a></li>
<li><a class="reference internal" href="#what-s-the-difference-between-globals-and-mod-dict-for-lazy-imports">What’s the difference between <code class="docutils literal notranslate"><span class="pre">globals()</span></code> and <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> for lazy imports?</a></li>
<li><a class="reference internal" href="#why-not-use-importlib-util-lazyloader-instead">Why not use <code class="docutils literal notranslate"><span class="pre">importlib.util.LazyLoader</span></code> instead?</a></li>
<li><a class="reference internal" href="#will-this-break-tools-like-isort-or-black">Will this break tools like <code class="docutils literal notranslate"><span class="pre">isort</span></code> or <code class="docutils literal notranslate"><span class="pre">black</span></code>?</a></li>
<li><a class="reference internal" href="#how-do-i-know-if-a-library-is-compatible-with-lazy-imports">How do I know if a library is compatible with lazy imports?</a></li>
<li><a class="reference internal" href="#what-happens-if-i-globally-enable-lazy-imports-mode-and-a-library-doesn-t-work-correctly">What happens if I globally enable lazy imports mode and a library doesn’t work correctly?</a></li>
<li><a class="reference internal" href="#can-i-use-lazy-imports-inside-functions">Can I use lazy imports inside functions?</a></li>
<li><a class="reference internal" href="#what-about-forwards-compatibility-with-older-python-versions">What about forwards compatibility with older Python versions?</a></li>
<li><a class="reference internal" href="#how-do-explicit-lazy-imports-interact-with-pep-649-and-pep-749">How do explicit lazy imports interact with PEP 649 and PEP 749?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-interact-with-dir-getattr-and-module-introspection">How do lazy imports interact with <code class="docutils literal notranslate"><span class="pre">dir()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, and module introspection?</a></li>
<li><a class="reference internal" href="#do-lazy-imports-work-with-circular-imports">Do lazy imports work with circular imports?</a></li>
<li><a class="reference internal" href="#will-lazy-imports-affect-the-performance-of-my-hot-paths">Will lazy imports affect the performance of my hot paths?</a></li>
<li><a class="reference internal" href="#what-about-sys-modules-when-does-a-lazy-import-appear-there">What about <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>? When does a lazy import appear there?</a></li>
<li><a class="reference internal" href="#does-lazy-from-future-import-feature-work">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">feature</span></code> work?</a></li>
<li><a class="reference internal" href="#why-you-chose-lazy-as-the-keyword-name">Why you chose <code class="docutils literal notranslate"><span class="pre">lazy</span></code> as the keyword name?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-implementation-ideas">Alternate Implementation Ideas</a><ul>
<li><a class="reference internal" href="#leveraging-a-subclass-of-dict">Leveraging a subclass of dict</a></li>
<li><a class="reference internal" href="#alternate-keyword-names">Alternate keyword names</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#making-the-new-behavior-the-default">Making the new behavior the default</a></li>
<li><a class="reference internal" href="#modification-of-the-dict-object">Modification of the dict object</a></li>
<li><a class="reference internal" href="#making-lazy-imports-find-the-module-without-loading-it">Making <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports find the module without loading it</a></li>
<li><a class="reference internal" href="#placing-the-lazy-keyword-in-the-middle-of-from-imports">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword in the middle of from imports</a></li>
<li><a class="reference internal" href="#placing-the-lazy-keyword-at-the-end-of-import-statements">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword at the end of import statements</a></li>
<li><a class="reference internal" href="#adding-an-explicit-eager-keyword">Adding an explicit <code class="docutils literal notranslate"><span class="pre">eager</span></code> keyword</a></li>
<li><a class="reference internal" href="#using-a-context-manager-instead-of-a-new-soft-keyword">Using a context manager instead of a new soft keyword</a></li>
<li><a class="reference internal" href="#returning-a-proxy-dict-from-globals">Returning a proxy dict from <code class="docutils literal notranslate"><span class="pre">globals()</span></code></a></li>
<li><a class="reference internal" href="#reifying-lazy-imports-when-globals-is-called">Reifying lazy imports when <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is called</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP introduces syntax for lazy imports as an explicit language feature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumps</span>
</pre></div>
</div>
<p>Lazy imports defer the loading and execution of a module until the first time
the imported name is used, in contrast to ‘normal’ imports, which eagerly load
and execute a module at the point of the import statement.</p>
<p>By allowing developers to mark individual imports as lazy with explicit
syntax, Python programs can reduce startup time, memory usage, and unnecessary
work. This is particularly beneficial for command-line tools, test suites, and
applications with large dependency graphs.</p>
<p>This proposal preserves full backwards compatibility: normal import statements
remain unchanged, and lazy imports are enabled only where explicitly
requested.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>The dominant convention in Python code is to place all imports at the module
level, typically at the beginning of the file. This avoids repetition, makes
import dependencies clear and minimizes runtime overhead by only evaluating an
import statement once per module.</p>
<p>A major drawback with this approach is that importing the first module for an
execution of Python (the “main” module) often triggers an immediate cascade of
imports, and optimistically loads many dependencies that may never be used.
The effect is especially costly for command-line tools with multiple
subcommands, where even running the command with <code class="docutils literal notranslate"><span class="pre">--help</span></code> can load dozens of
unnecessary modules and take several seconds. This basic example demonstrates
what must be loaded just to get helpful feedback to the user on how to run the
program at all. Inefficiently, the user incurs this overhead again when they
figure out the command they want and invoke the program “for real.”</p>
<p>A somewhat common way to delay imports is to move the imports into functions
(inline imports), but this practice requires more work to implement and
maintain, and can be subverted by a single inadvertent top-level import.
Additionally, it obfuscates the full set of dependencies for a module.
Analysis of the Python standard library shows that approximately 17% of all
imports outside tests (nearly 3500 total imports across 730 files) are already
placed inside functions or methods specifically to defer their execution. This
demonstrates that developers are already manually implementing lazy imports in
performance-sensitive code, but doing so requires scattering imports
throughout the codebase and makes the full dependency graph harder to
understand at a glance.</p>
<p>The standard library provides the <a class="reference external" href="https://docs.python.org/3/library/importlib.html#importlib.util.LazyLoader" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">LazyLoader</span></code></a> class to
solve some of these inefficiency problems. It permits imports at the module
level to work <em>mostly</em> like inline imports do. Many scientific Python
libraries have adopted a similar pattern, formalized in
<a class="reference external" href="https://scientific-python.org/specs/spec-0001/">SPEC 1</a>.
There’s also the third-party <a class="extlink-pypi reference external" href="https://pypi.org/project/lazy_loader/">lazy_loader</a> package, yet another
implementation of lazy imports. Imports used solely for static type checking
are another source of potentially unneeded imports, and there are similarly
disparate approaches to minimizing the overhead. The various approaches used
here to defer or remove eager imports do not cover all potential use-cases for
a general lazy import mechanism. There is no clear standard, and there are
several drawbacks including runtime overhead in unexpected places, or worse
runtime introspection.</p>
<p>This proposal introduces syntax for lazy imports with a design that is local,
explicit, controlled, and granular. Each of these qualities is essential to
making the feature predictable and safe to use in practice.</p>
<p>The behavior is <strong>local</strong>: laziness applies only to the specific import marked
with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword, and it does not cascade recursively into other
imports. This ensures that developers can reason about the effect of laziness
by looking only at the line of code in front of them, without worrying about
whether imported modules will themselves behave differently. A <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code>
is an isolated decision each time it is used, not a global shift in semantics.</p>
<p>The semantics are <strong>explicit</strong>. When a name is imported lazily, the binding is
created in the importing module immediately, but the target module is not
loaded until the first time the name is accessed. After this point, the
binding is indistinguishable from one created by a normal import. This clarity
reduces surprises and makes the feature accessible to developers who may not
be deeply familiar with Python’s import machinery.</p>
<p>Lazy imports are <strong>controlled</strong>, in the sense that lazy loading is only
triggered by the importing code itself. In the general case, a library will
only experience lazy imports if its own authors choose to mark them as such.
This avoids shifting responsibility onto downstream users and prevents
accidental surprises in library behavior. Since library authors typically
manage their own import subgraphs, they retain predictable control over when
and how laziness is applied.</p>
<p>The mechanism is also <strong>granular</strong>. It is introduced through explicit syntax
on individual imports, rather than a global flag or implicit setting. This
allows developers to adopt it incrementally, starting with the most
performance-sensitive areas of a codebase. As this feature is introduced to
the community, we want to make the experience of onboarding optional,
progressive, and adaptable to the needs of each project.</p>
<p>Lazy imports provide several concrete advantages:</p>
<ul class="simple">
<li>Command-line tools are often invoked directly by a user, so latency – in
particular startup latency – is quite noticeable. These programs are also
typically short-lived processes (contrasted with, e.g., a web server). With
lazy imports, only the code paths actually reached will import a module.
This can reduce startup time by 50-70% in practice, providing a significant
improvement to a common user experience and improving Python’s
competitiveness in domains where fast startup matters most.</li>
<li>Type annotations frequently require imports that are never used at runtime.
The common workaround is to wrap them in <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING:</span></code> blocks
<a class="footnote-reference brackets" href="#f1" id="id1">[1]</a>. With lazy imports, annotation-only imports impose no runtime
penalty, eliminating the need for such guards and making annotated codebases
cleaner.</li>
<li>Large applications often import thousands of modules, and each module
creates function and type objects, incurring memory costs. In long-lived
processes, this noticeably raises baseline memory usage. Lazy imports defer
these costs until a module is needed, keeping unused subsystems unloaded.
Memory savings of 30-40% have been observed in real workloads.</li>
</ul>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>The design of this proposal is centered on clarity, predictability, and ease
of adoption. Each decision was made to ensure that lazy imports provide
tangible benefits without introducing unnecessary complexity into the language
or its runtime.</p>
<p>It is also worth noting that while this PEP outlines one specific approach, we
list alternate implementation strategies for some of the core aspects and
semantics of the proposal. If the community expresses a strong preference for
a different technical path that still preserves the same core semantics or
there is fundamental disagreement over the specific option, we have included
the brainstorming we have already completed in preparation for this proposal
as reference.</p>
<p>The choice to introduce a new <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword reflects the need for explicit
syntax. Import behavior is too fundamental to be left implicit or hidden
behind global flags or environment variables. By marking laziness directly at
the import site, the intent is immediately visible to both readers and tools.
This avoids surprises, reduces the cognitive burden of reasoning about
imports, and keeps lazy import semantics in line with Python’s tradition of
explicitness.</p>
<p>Another important decision is to represent lazy imports with proxy objects in
the module’s namespace, rather than by modifying dictionary lookup. Earlier
approaches experimented with embedding laziness into dictionaries, but this
blurred abstractions and risked affecting unrelated parts of the runtime. The
dictionary is a fundamental data structure in Python – literally every object
is built on top of dicts – and adding hooks to dictionaries would prevent
critical optimizations and complicate the entire runtime. The proxy approach
is simpler: it behaves like a placeholder until first use, at which point it
resolves the import and rebinds the name. From then on, the binding is
indistinguishable from a normal import. This makes the mechanism easy to
explain and keeps the rest of the interpreter unchanged.</p>
<p>Compatibility for library authors was also a key concern. Many maintainers
need a migration path that allows them to support both new and old versions of
Python at once. For this reason, the proposal includes the
<code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> global as a transitional mechanism. A module can
declare which imports should be treated as lazy (by listing the module names
as strings), and on Python 3.15 or later those imports will become lazy
automatically, as if they were imported with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword. On earlier
versions the declaration is ignored, leaving imports eager. This gives authors
a practical bridge until they can rely on the keyword as the canonical syntax.</p>
<p>Finally, the feature is designed to be adopted incrementally. Nothing changes
unless a developer explicitly opts in, and adoption can begin with just a few
imports in performance-sensitive areas. This mirrors the experience of gradual
typing in Python: a mechanism that can be introduced progressively, without
forcing projects to commit globally from day one. Notably, the adoption can
also be done from the “outside in”, permitting CLI authors to introduce lazy
imports and speed up user-facing tools, without requiring changes to every
library the tool might use.</p>
<section id="other-design-decisions">
<h3><a class="toc-backref" href="#other-design-decisions" role="doc-backlink">Other design decisions</a></h3>
<ul class="simple">
<li>The scope of laziness is deliberately local and non-recursive. A lazy import
only affects the specific statement where it appears; it does not cascade
into other modules or submodules. This choice is crucial for predictability.
When developers read code, they can reason about import behavior line by
line, without worrying about hidden laziness deeper in the dependency graph.
The result is a feature that is powerful but still easy to understand in
context.</li>
<li>In addition, it is useful to provide a mechanism to activate or deactivate
lazy imports for all code running in the interpreter
(referred to in this PEP as the ‘global lazy imports flag’).
While the primary design centers the explicit <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span></code> syntax,
there are scenarios – such as large applications, testing environments,
or frameworks – where enabling laziness consistently across
many modules provides the most benefit. A global switch makes it easy to
experiment with or enforce consistent behavior, while still working in
combination with the filtering API to respect exclusions or tool-specific
configuration. This ensures that global adoption can be practical without
reducing flexibility or control.</li>
</ul>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<section id="grammar">
<h3><a class="toc-backref" href="#grammar" role="doc-backlink">Grammar</a></h3>
<p>A new soft keyword <code class="docutils literal notranslate"><span class="pre">lazy</span></code> is added. A soft keyword is a context-sensitive
keyword that only has special meaning in specific grammatical contexts;
elsewhere it can be used as a regular identifier (e.g., as a variable name).
The <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword only has special meaning when it appears before import
statements:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>import_name:
    | &#39;lazy&#39;? &#39;import&#39; dotted_as_names

import_from:
    | &#39;lazy&#39;? &#39;from&#39; (&#39;.&#39; | &#39;...&#39;)* dotted_name &#39;import&#39; import_from_targets
    | &#39;lazy&#39;? &#39;from&#39; (&#39;.&#39; | &#39;...&#39;)+ &#39;import&#39; import_from_targets
</pre></div>
</div>
<section id="syntax-restrictions">
<h4><a class="toc-backref" href="#syntax-restrictions" role="doc-backlink">Syntax restrictions</a></h4>
<p>The soft keyword is only allowed at the global (module) level, <strong>not</strong> inside
functions, class bodies, with <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">with</span></code> blocks, or <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span></code>. Import
statements that use the soft keyword are <em>potentially lazy</em>. Imports that
can’t be lazy are unaffected by the global lazy imports flag, and instead are
always eager.</p>
<p>Examples of syntax errors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># SyntaxError: lazy import not allowed inside functions</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">():</span>
    <span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># SyntaxError: lazy import not allowed inside classes</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Bar</span><span class="p">:</span>
    <span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># SyntaxError: lazy import not allowed inside try/except blocks</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># SyntaxError: lazy import not allowed inside with blocks</span>
<span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">ImportError</span><span class="p">):</span>
    <span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># SyntaxError: lazy from ... import * is not allowed</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</section>
</section>
<section id="semantics">
<h3><a class="toc-backref" href="#semantics" role="doc-backlink">Semantics</a></h3>
<p>When the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword is used, the import becomes <em>potentially lazy</em>.
Unless lazy imports are disabled or suppressed (see below), the module is not
loaded immediately at the import statement; instead, a lazy proxy object is
created and bound to the name. The actual module is loaded on first use of
that name.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False - module not loaded yet</span>

<span class="c1"># First use triggers loading</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;hello&quot;</span><span class="p">:</span> <span class="s2">&quot;world&quot;</span><span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True - now loaded</span>
</pre></div>
</div>
<p>A module may contain a <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> attribute, which is a
sequence of fully qualified module names (strings) to make <em>potentially lazy</em>
(as if the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword was used). This attribute is checked on each
<code class="docutils literal notranslate"><span class="pre">import</span></code> statement to determine whether the import should be made
<em>potentially lazy</em>. When a module is made lazy this way, from-imports using
that module are also lazy, but not necessarily imports of sub-modules.</p>
<p>The normal (non-lazy) import statement will check the global lazy imports
flag. If it is “enabled”, all imports are <em>potentially lazy</em> (except for
imports that can’t be lazy, as mentioned above.)</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">__lazy_modules__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;json&quot;</span><span class="p">]</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;hello&quot;</span><span class="p">:</span> <span class="s2">&quot;world&quot;</span><span class="p">})</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True</span>
</pre></div>
</div>
<p>If the global lazy imports flag is set to “disabled”, no <em>potentially lazy</em>
import is ever imported lazily, and the behavior is equivalent to a regular
import statement: the import is <em>eager</em> (as if the lazy keyword was not used).</p>
<p>Finally, the application may use a custom filter function on all <em>potentially
lazy</em> imports to determine if they should be lazy or not.
If a filter function is set, it will be called with the name of the module
doing the import, the name of the module being imported, and (if applicable)
the fromlist.
An import remains lazy only if the filter function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>If no lazy import filter is set, all <em>potentially lazy</em> imports are lazy.</p>
</section>
<section id="lazy-import-mechanism">
<h3><a class="toc-backref" href="#lazy-import-mechanism" role="doc-backlink">Lazy import mechanism</a></h3>
<p>When an import is lazy, <code class="docutils literal notranslate"><span class="pre">__lazy_import__</span></code> is called instead of
<code class="docutils literal notranslate"><span class="pre">__import__</span></code>. <code class="docutils literal notranslate"><span class="pre">__lazy_import__</span></code> has the same function signature as
<code class="docutils literal notranslate"><span class="pre">__import__</span></code>. It adds the module name to <code class="docutils literal notranslate"><span class="pre">sys.lazy_modules</span></code>, a set of
fully-qualified module names which have been lazily imported at some point
(primarily for diagnostics and introspection), and returns a “lazy module
object.”</p>
<p>The implementation of <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> (the <code class="docutils literal notranslate"><span class="pre">IMPORT_FROM</span></code> bytecode
implementation) checks if the module it’s fetching from is a lazy module
object, and if so, returns a lazy object for each name instead.</p>
<p>The end result of this process is that lazy imports (regardless of how they
are enabled) result in lazy objects being assigned to global variables.</p>
<p>Lazy module objects do not appear in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>, they’re just listed in
the <code class="docutils literal notranslate"><span class="pre">sys.lazy_modules</span></code> set. Under normal operation lazy objects should only
end up stored in global variables, and the common ways to access those
variables (regular variable access, module attributes) will resolve lazy
imports (“reify”) and replace them when they’re accessed.</p>
<p>It is still possible to expose lazy objects through other means, like
debuggers. This is not considered a problem.</p>
</section>
<section id="reification">
<h3><a class="toc-backref" href="#reification" role="doc-backlink">Reification</a></h3>
<p>When a lazy object is first used, it needs to be reified. This means resolving
the import at that point in the program and replacing the lazy object with the
concrete one. Reification imports the module in the same way as it would have
been if it had been imported eagerly, barring intervening changes to the
import system (e.g. to <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> or
<code class="docutils literal notranslate"><span class="pre">__import__</span></code>).</p>
<p>Reification still calls <code class="docutils literal notranslate"><span class="pre">__import__</span></code> to resolve the import. When the module
is first reified, it’s removed from <code class="docutils literal notranslate"><span class="pre">sys.lazy_modules</span></code> (even if there are
still other unreified lazy references to it). When a package is reified and
submodules in the package were also previously lazily imported, those
submodules are <em>not</em> automatically reified but they <em>are</em> added to the reified
package’s globals (unless the package already assigned something else to the
name of the submodule).</p>
<p>If reification fails (e.g., due to an <code class="docutils literal notranslate"><span class="pre">ImportError</span></code>), the exception is
enhanced with chaining to show both where the lazy import was defined and
where it was first accessed (even though it propagates from the code that
triggered reification). This provides clear debugging information:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># app.py - has a typo in the import</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumsp</span>  <span class="c1"># Typo: should be &#39;dumps&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;App started successfully&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing data...&quot;</span><span class="p">)</span>

<span class="c1"># Error occurs here on first use</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">dumsp</span><span class="p">({</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>The traceback shows both locations:</p>
<div class="highlight-pytb notranslate"><div class="highlight"><pre><span></span><span class="x">App started successfully</span>
<span class="x">Processing data...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;app.py&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumsp</span>
<span class="gr">ImportError</span>: <span class="n">lazy import of &#39;json.dumsp&#39; raised an exception during resolution</span>

<span class="gt">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;app.py&quot;</span>, line <span class="m">8</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">result</span> <span class="o">=</span> <span class="n">dumsp</span><span class="p">({</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
<span class="w">             </span><span class="pm">^^^^^</span>
<span class="gr">ImportError</span>: <span class="n">cannot import name &#39;dumsp&#39; from &#39;json&#39;. Did you mean: &#39;dump&#39;?</span>
</pre></div>
</div>
<p>This exception chaining clearly shows:</p>
<ol class="arabic simple">
<li>where the lazy import was defined,</li>
<li>that the module was not eagerly imported, and</li>
<li>where the actual access happened that triggered the error.</li>
</ol>
<p>Reification does <strong>not</strong> automatically occur when a module that was previously
lazily imported is subsequently eagerly imported. Reification does <strong>not</strong>
immediately resolve all lazy objects (e.g. <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span></code> statements) that
referenced the module. It <strong>only</strong> resolves the lazy object being accessed.</p>
<p>Accessing a lazy object (from a global variable or a module attribute) reifies
the object. Accessing a module’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> reifies <strong>all</strong> lazy objects in
that module. Operations that indirectly access <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> (such as
<a class="reference external" href="https://docs.python.org/3/library/functions.html#dir" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a>) also trigger this behavior.</p>
<p>Example using <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> from external code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># my_module.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False - still lazy</span>

<span class="c1"># main.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">my_module</span>

<span class="c1"># Accessing __dict__ from external code DOES reify all lazy imports</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">my_module</span><span class="o">.</span><span class="vm">__dict__</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True - reified by __dict__ access</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]))</span>  <span class="c1"># &lt;class &#39;module&#39;&gt;</span>
</pre></div>
</div>
<p>However, calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> does <strong>not</strong> trigger reification – it returns
the module’s dictionary, and accessing lazy objects through that dictionary
still returns lazy proxy objects that need to be manually reified upon use. A
lazy object can be resolved explicitly by calling the <code class="docutils literal notranslate"><span class="pre">get</span></code> method. Other,
more indirect ways of accessing arbitrary globals (e.g. inspecting
<code class="docutils literal notranslate"><span class="pre">frame.f_globals</span></code>) also do <strong>not</strong> reify all the objects.</p>
<p>Example using <code class="docutils literal notranslate"><span class="pre">globals()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># Calling globals() does NOT trigger reification</span>
<span class="n">g</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False - still lazy</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]))</span>  <span class="c1"># &lt;class &#39;lazy_import&#39;&gt;</span>

<span class="c1"># Explicitly reify using the get() method</span>
<span class="n">resolved</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">resolved</span><span class="p">))</span>  <span class="c1"># &lt;class &#39;module&#39;&gt;</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True - now loaded</span>
</pre></div>
</div>
</section>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>A reference implementation is available at:
<a class="reference external" href="https://github.com/LazyImportsCabal/cpython/tree/lazy">https://github.com/LazyImportsCabal/cpython/tree/lazy</a></p>
<section id="bytecode-and-adaptive-specialization">
<h3><a class="toc-backref" href="#bytecode-and-adaptive-specialization" role="doc-backlink">Bytecode and adaptive specialization</a></h3>
<p>Lazy imports are implemented through modifications to four bytecode
instructions: <code class="docutils literal notranslate"><span class="pre">IMPORT_NAME</span></code>, <code class="docutils literal notranslate"><span class="pre">IMPORT_FROM</span></code>, <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code>, and
<code class="docutils literal notranslate"><span class="pre">LOAD_NAME</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">lazy</span></code> syntax sets a flag in the <code class="docutils literal notranslate"><span class="pre">IMPORT_NAME</span></code> instruction’s oparg
(<code class="docutils literal notranslate"><span class="pre">oparg</span> <span class="pre">&amp;</span> <span class="pre">0x01</span></code>). The interpreter checks this flag and calls
<code class="docutils literal notranslate"><span class="pre">_PyEval_LazyImportName()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">_PyEval_ImportName()</span></code>, creating a
lazy import object rather than executing the import immediately. The
<code class="docutils literal notranslate"><span class="pre">IMPORT_FROM</span></code> instruction checks whether its source is a lazy import
(<code class="docutils literal notranslate"><span class="pre">PyLazyImport_CheckExact()</span></code>) and creates a lazy object for the attribute
rather than accessing it immediately.</p>
<p>When a lazy object is accessed, it must be reified. The <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code>
instruction (used in function scopes) and <code class="docutils literal notranslate"><span class="pre">LOAD_NAME</span></code> instruction (used at
module and class level) both check whether the object being loaded is a lazy
import. If so, they call <code class="docutils literal notranslate"><span class="pre">_PyImport_LoadLazyImportTstate()</span></code> to perform the
actual import and store the module in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>.</p>
<p>This check incurs a very small cost on each access. However, Python’s adaptive
interpreter can specialize <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> after observing that a lazy import
has been reified. After several executions, <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code>, which accesses the module dictionary directly without
checking for lazy imports.</p>
<p>Examples of the bytecode generated:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>  <span class="c1"># IMPORT_NAME with flag set</span>
</pre></div>
</div>
<p>Generates:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>IMPORT_NAME              1 (json + lazy)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">json</span><span class="w"> </span><span class="kn">import</span> <span class="n">dumps</span>  <span class="c1"># IMPORT_NAME + IMPORT_FROM</span>
</pre></div>
</div>
<p>Generates:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>IMPORT_NAME              1 (json + lazy)
IMPORT_FROM              1 (dumps)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">json</span>  <span class="c1"># Module-level access</span>
</pre></div>
</div>
<p>Generates:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>LOAD_NAME                0 (json)
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="k">def</span><span class="w"> </span><span class="nf">use_json</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({})</span>  <span class="c1"># Function scope</span>
</pre></div>
</div>
<p>Before any calls:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)
</pre></div>
</div>
<p>After several calls, <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code> specializes to <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
</pre></div>
</div>
</section>
<section id="lazy-imports-filter">
<h3><a class="toc-backref" href="#lazy-imports-filter" role="doc-backlink">Lazy imports filter</a></h3>
<p>This PEP adds two new functions to the <code class="docutils literal notranslate"><span class="pre">sys</span></code> module to manage the lazy
imports filter:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports_filter(func)</span></code> - Sets the filter function. The
<code class="docutils literal notranslate"><span class="pre">func</span></code> parameter must have the signature: <code class="docutils literal notranslate"><span class="pre">func(importer:</span> <span class="pre">str,</span> <span class="pre">name:</span> <span class="pre">str,</span>
<span class="pre">fromlist:</span> <span class="pre">tuple[str,</span> <span class="pre">...]</span> <span class="pre">|</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">sys.get_lazy_imports_filter()</span></code> - Returns the currently installed filter
function, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no filter is set.</li>
</ul>
<p>The filter function is called for every potentially lazy import, and must
return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the import should be lazy. This allows for fine-grained
control over which imports should be lazy, useful for excluding modules with
known side-effect dependencies or registration patterns.</p>
<p>The filter mechanism serves as a foundation that tools, debuggers, linters,
and other ecosystem utilities can leverage to provide better lazy import
experiences. For example, static analysis tools could detect modules with side
effects and automatically configure appropriate filters. <strong>In the future</strong>
(out of scope for this PEP), this foundation may enable better ways to
declaratively specify which modules are safe for lazy importing, such as
package metadata, type stubs with lazy-safety annotations, or configuration
files. The current filter API is designed to be flexible enough to accommodate
such future enhancements without requiring changes to the core language
specification.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="k">def</span><span class="w"> </span><span class="nf">exclude_side_effect_modules</span><span class="p">(</span><span class="n">importer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fromlist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter function to exclude modules with import-time side effects.</span>

<span class="sd">    Args:</span>
<span class="sd">        importer: Name of the module doing the import</span>
<span class="sd">        name: Name of the module being imported</span>
<span class="sd">        fromlist: Tuple of names being imported (for &#39;from&#39; imports), or None</span>

<span class="sd">    Returns:</span>
<span class="sd">        True to allow lazy import, False to force eager import</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Modules known to have important import-time side effects</span>
    <span class="n">side_effect_modules</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;legacy_plugin_system&#39;</span><span class="p">,</span> <span class="s1">&#39;metrics_collector&#39;</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">side_effect_modules</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Force eager import</span>

    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Allow lazy import</span>

<span class="c1"># Install the filter</span>
<span class="n">sys</span><span class="o">.</span><span class="n">set_lazy_imports_filter</span><span class="p">(</span><span class="n">exclude_side_effect_modules</span><span class="p">)</span>

<span class="c1"># These imports are checked by the filter</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">data_processor</span>        <span class="c1"># Filter returns True -&gt; stays lazy</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">legacy_plugin_system</span>  <span class="c1"># Filter returns False -&gt; imported eagerly</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;data_processor&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>       <span class="c1"># False - still lazy</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;legacy_plugin_system&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span> <span class="c1"># True - loaded eagerly</span>

<span class="c1"># First use of data_processor triggers loading</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">data_processor</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;data_processor&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>       <span class="c1"># True - now loaded</span>
</pre></div>
</div>
</section>
<section id="global-lazy-imports-control">
<h3><a class="toc-backref" href="#global-lazy-imports-control" role="doc-backlink">Global lazy imports control</a></h3>
<p>The global lazy imports flag can be controlled through:</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">-X</span> <span class="pre">lazy_imports=&lt;mode&gt;</span></code> command-line option</li>
<li>The <code class="docutils literal notranslate"><span class="pre">PYTHON_LAZY_IMPORTS=&lt;mode&gt;</span></code> environment variable</li>
<li>The <code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports(mode)</span></code> function (primarily for testing)</li>
</ul>
<p>Where <code class="docutils literal notranslate"><span class="pre">&lt;mode&gt;</span></code> can be:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> (or unset): Only explicitly marked lazy imports are lazy</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;enabled&quot;</span></code>: All module-level imports (except in <code class="docutils literal notranslate"><span class="pre">try</span></code>  or <code class="docutils literal notranslate"><span class="pre">with</span></code>
blocks and <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span></code>) become <em>potentially lazy</em></li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;disabled&quot;</span></code>: No imports are lazy, even those explicitly marked with
<code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword</li>
</ul>
<p>When the global flag is set to <code class="docutils literal notranslate"><span class="pre">&quot;enabled&quot;</span></code>, all imports at the global level
of all modules are <em>potentially lazy</em> <strong>except</strong> for those inside a <code class="docutils literal notranslate"><span class="pre">try</span></code> or
<code class="docutils literal notranslate"><span class="pre">with</span></code> block or any wild card (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">*</span></code>) import.</p>
<p>If the global lazy imports flag is set to <code class="docutils literal notranslate"><span class="pre">&quot;disabled&quot;</span></code>, no <em>potentially
lazy</em> import is ever imported lazily, the import filter is never called, and
the behavior is equivalent to a regular <code class="docutils literal notranslate"><span class="pre">import</span></code> statement: the import is
<em>eager</em> (as if the lazy keyword was not used).</p>
<p>Python code can run the <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_lazy_imports()</span></code> function to override
the state of the global lazy imports flag inherited from the environment or CLI.
This is especially useful if an application needs to ensure that all imports
are evaluated eagerly, via <code class="docutils literal notranslate"><span class="pre">sys.set_lazy_imports('disabled')</span></code>.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>Lazy imports are <strong>opt-in</strong>. Existing programs continue to run unchanged
unless a project explicitly enables laziness (via <code class="docutils literal notranslate"><span class="pre">lazy</span></code> syntax,
<code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code>, or an interpreter-wide switch).</p>
<section id="unchanged-semantics">
<h3><a class="toc-backref" href="#unchanged-semantics" role="doc-backlink">Unchanged semantics</a></h3>
<ul class="simple">
<li>Regular <code class="docutils literal notranslate"><span class="pre">import</span></code> and <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> statements remain eager
unless explicitly made <em>potentially lazy</em> by the local or global mechanisms
provided.</li>
<li>Dynamic import APIs remain eager and unchanged: <code class="docutils literal notranslate"><span class="pre">__import__()</span></code> and
<code class="docutils literal notranslate"><span class="pre">importlib.import_module()</span></code>.</li>
<li>Import hooks and loaders continue to run under the standard import protocol
when a lazy object is reified.</li>
</ul>
</section>
<section id="observable-behavioral-shifts-opt-in-only">
<h3><a class="toc-backref" href="#observable-behavioral-shifts-opt-in-only" role="doc-backlink">Observable behavioral shifts (opt-in only)</a></h3>
<p>These changes are limited to bindings explicitly made lazy:</p>
<ul>
<li><strong>Error timing.</strong> Exceptions that would have occurred during an eager import
(for example <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> or <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> for a missing member) now
occur at the first <em>use</em> of the lazy name.<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># With eager import - error at import statement</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">broken_module</span>  <span class="c1"># ImportError raised here</span>

<span class="c1"># With lazy import - error deferred</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">broken_module</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Import succeeded&quot;</span><span class="p">)</span>
<span class="n">broken_module</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>  <span class="c1"># ImportError raised here on first use</span>
</pre></div>
</div>
</li>
<li><strong>Side-effect timing.</strong> Import-time side effects in lazily imported modules
occur at first use of the binding, not at module import time.</li>
<li><strong>Import order.</strong> Because modules are imported on first use, the order in
which modules are imported may differ from how they appear in code.</li>
<li><strong>Presence in ``sys.modules``.</strong> A lazily imported module does not appear in
<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> until first use. After reification, it must appear in
<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>. If some other code eagerly imports the same module before
first use, the lazy binding resolves to that existing (lazy) module object
when it is first used.</li>
<li><strong>Proxy visibility.</strong> Before first use, the bound name refers to a lazy
proxy. Indirect introspection that touches the value may observe a proxy
lazy object representation. After first use, the name is rebound to the real
object and becomes indistinguishable from an eager import.</li>
</ul>
</section>
<section id="thread-safety-and-reification">
<h3><a class="toc-backref" href="#thread-safety-and-reification" role="doc-backlink">Thread-safety and reification</a></h3>
<p>First use of a lazy binding follows the existing import-lock discipline.
Exactly one thread performs the import and <strong>atomically rebinds</strong> the
importing module’s global to the resolved object. Concurrent readers
thereafter observe the real object.</p>
<p>Lazy imports are thread-safe and have no special considerations for
free-threading. A module that would normally be imported in the main thread
may be imported in a different thread if that thread triggers the first access
to the lazy import. This is not a problem: the import lock ensures thread
safety regardless of which thread performs the import.</p>
<p>Subinterpreters are supported. Each subinterpreter maintains its own
<code class="docutils literal notranslate"><span class="pre">sys.lazy_modules</span></code> and import state, so lazy imports in one subinterpreter
do not affect others.</p>
</section>
<section id="typing-and-tools">
<h3><a class="toc-backref" href="#typing-and-tools" role="doc-backlink">Typing and tools</a></h3>
<p>Type checkers and static analyzers may treat <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports as ordinary
imports for name resolution. At runtime, annotation-only imports can be marked
<code class="docutils literal notranslate"><span class="pre">lazy</span></code> to avoid startup overhead. IDEs and debuggers should be prepared to
display lazy proxies before first use and the real objects thereafter.</p>
</section>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>There are no known security vulnerabilities introduced by lazy imports.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>The new <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword will be documented as part of the language standard.</p>
<p>As this feature is opt-in, new Python users should be able to continue using
the language as they are used to. For experienced developers, we expect them
to leverage lazy imports for the variety of benefits listed above (decreased
latency, decreased memory usage, etc) on a case-by-case basis. Developers
interested in the performance of their Python binary will likely leverage
profiling to understand the import time overhead in their codebase and mark
the necessary imports as <code class="docutils literal notranslate"><span class="pre">lazy</span></code>. In addition, developers can mark imports
that will only be used for type annotations as <code class="docutils literal notranslate"><span class="pre">lazy</span></code>.</p>
<p>Below is guidance on how to best take advantage of lazy imports and how to
avoid incompatibilities:</p>
<ul>
<li>When adopting lazy imports, users should be aware that eliding an import
until it is used will result in side effects not being executed. In turn,
users should be wary of modules that rely on import time side effects.
Perhaps the most common reliance on import side effects is the registry
pattern, where population of some external registry happens implicitly
during the importing of modules, often via decorators but sometimes
implemented via metaclasses or <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. Instead, registries of
objects should be constructed via explicit discovery processes (e.g. a
well-known function to call).<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Problematic: Plugin registers itself on import</span>
<span class="c1"># my_plugin.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">plugin_registry</span><span class="w"> </span><span class="kn">import</span> <span class="n">register_plugin</span>

<span class="nd">@register_plugin</span><span class="p">(</span><span class="s2">&quot;MyPlugin&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyPlugin</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># In main code:</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">my_plugin</span>
<span class="c1"># Plugin NOT registered yet - module not loaded!</span>

<span class="c1"># Better: Explicit discovery</span>
<span class="c1"># plugin_registry.py</span>
<span class="k">def</span><span class="w"> </span><span class="nf">discover_plugins</span><span class="p">():</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">my_plugin</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyPlugin</span>
    <span class="n">register_plugin</span><span class="p">(</span><span class="n">MyPlugin</span><span class="p">)</span>

<span class="c1"># In main code:</span>
<span class="n">plugin_registry</span><span class="o">.</span><span class="n">discover_plugins</span><span class="p">()</span>  <span class="c1"># Explicit loading</span>
</pre></div>
</div>
</li>
<li>Always import needed submodules explicitly. It is not enough to rely on a
different import to ensure a module has its submodules as attributes.
Plainly, unless there is an explicit <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">bar</span></code> in
<code class="docutils literal notranslate"><span class="pre">foo/__init__.py</span></code>, always use <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo.bar;</span> <span class="pre">foo.bar.Baz</span></code>, not
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo;</span> <span class="pre">foo.bar.Baz</span></code>. The latter only works (unreliably) because the
attribute <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> is added as a side effect of <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> being
imported somewhere else.</li>
<li>Users who are moving imports into functions to improve startup time, should
instead consider keeping them where they are but adding the <code class="docutils literal notranslate"><span class="pre">lazy</span></code>
keyword. This allows them to keep dependencies clear and avoid the overhead
of repeatedly re-resolving the import but will still speed up the program.<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Before: Inline import (repeated overhead)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>  <span class="c1"># Re-resolved on every call</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># After: Lazy import at module level</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># Loaded once on first call</span>
</pre></div>
</div>
</li>
<li>Avoid using wild card (star) imports, as those are always eager.</li>
</ul>
</section>
<section id="faq">
<h2><a class="toc-backref" href="#faq" role="doc-backlink">FAQ</a></h2>
<section id="how-does-this-differ-from-the-rejected-pep-690">
<h3><a class="toc-backref" href="#how-does-this-differ-from-the-rejected-pep-690" role="doc-backlink">How does this differ from the rejected PEP 690?</a></h3>
<p>PEP 810 takes an explicit, opt-in approach instead of <a class="pep reference internal" href="../pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a>’s implicit
global approach. The key differences are:</p>
<ul class="simple">
<li><strong>Explicit syntax</strong>: <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span> <span class="pre">foo</span></code> clearly marks which imports are
lazy.</li>
<li><strong>Local scope</strong>: Laziness only affects the specific import statement, not
cascading to dependencies.</li>
<li><strong>Simpler implementation</strong>: Uses proxy objects instead of modifying core
dictionary behavior.</li>
</ul>
</section>
<section id="what-happens-when-lazy-imports-encounter-errors">
<h3><a class="toc-backref" href="#what-happens-when-lazy-imports-encounter-errors" role="doc-backlink">What happens when lazy imports encounter errors?</a></h3>
<p>Import errors (<code class="docutils literal notranslate"><span class="pre">ImportError</span></code>, <code class="docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code>, syntax errors) are
deferred until first use of the lazy name. This is similar to moving an import
into a function. The error will occur with a clear traceback pointing to the
first access of the lazy object.</p>
<p>The implementation provides enhanced error reporting through exception
chaining. When a lazy import fails during reification, the original exception
is preserved and chained, showing both where the import was defined and where
it was first used:</p>
<div class="highlight-pytb notranslate"><div class="highlight"><pre><span></span><span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;test.py&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">broken_module</span>
<span class="gr">ImportError</span>: <span class="n">lazy import of &#39;broken_module&#39; raised an exception during resolution</span>

<span class="gt">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;test.py&quot;</span>, line <span class="m">3</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">broken_module</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="w">    </span><span class="pm">^^^^^^^^^^^^^</span>
  File <span class="nb">&quot;broken_module.py&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>
</pre></div>
</div>
</section>
<section id="how-do-lazy-imports-affect-modules-with-import-time-side-effects">
<h3><a class="toc-backref" href="#how-do-lazy-imports-affect-modules-with-import-time-side-effects" role="doc-backlink">How do lazy imports affect modules with import-time side effects?</a></h3>
<p>Side effects are deferred until first use. This is generally desirable for
performance, but may require code changes for modules that rely on import-time
registration patterns. We recommend:</p>
<ul class="simple">
<li>Use explicit initialization functions instead of import-time side effects</li>
<li>Call initialization functions explicitly when needed</li>
<li>Avoid relying on import order for side effects</li>
</ul>
</section>
<section id="can-i-use-lazy-imports-with-from-import-statements">
<h3><a class="toc-backref" href="#can-i-use-lazy-imports-with-from-import-statements" role="doc-backlink">Can I use lazy imports with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> statements?</a></h3>
<p>Yes, as long as you don’t use <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">*</span></code>. Both <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">import</span>
<span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">foo</span> <span class="pre">import</span> <span class="pre">bar</span></code> are supported. The <code class="docutils literal notranslate"><span class="pre">bar</span></code> name will be
bound to a lazy object that resolves to <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> on first use.</p>
</section>
<section id="does-lazy-from-module-import-class-load-the-entire-module-or-just-the-class">
<h3><a class="toc-backref" href="#does-lazy-from-module-import-class-load-the-entire-module-or-just-the-class" role="doc-backlink">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Class</span></code> load the entire module or just the class?</a></h3>
<p>It loads the <strong>entire module</strong>, not just the class. This is because
Python’s import system always executes the complete module file – there’s no
mechanism to execute only part of a <code class="docutils literal notranslate"><span class="pre">.py</span></code> file. When you first access
<code class="docutils literal notranslate"><span class="pre">Class</span></code>, Python:</p>
<ol class="arabic simple">
<li>Loads and executes the entire <code class="docutils literal notranslate"><span class="pre">module.py</span></code> file</li>
<li>Extracts the <code class="docutils literal notranslate"><span class="pre">Class</span></code> attribute from the resulting module object</li>
<li>Binds <code class="docutils literal notranslate"><span class="pre">Class</span></code> to the name in your namespace</li>
</ol>
<p>This is identical to eager <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Class</span></code> behavior. The only
difference with lazy imports is that steps 1-3 happen on first use instead of
at the import statement.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># heavy_module.py</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading heavy_module&quot;</span><span class="p">)</span>  <span class="c1"># This ALWAYS runs when module loads</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">UnusedClass</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c1"># Also gets defined, even though we don&#39;t import it</span>

<span class="c1"># app.py</span>
<span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">heavy_module</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyClass</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Import statement done&quot;</span><span class="p">)</span>  <span class="c1"># heavy_module not loaded yet</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>                  <span class="c1"># NOW &quot;Loading heavy_module&quot; prints</span>
                                 <span class="c1"># (and UnusedClass gets defined too)</span>
</pre></div>
</div>
<p><strong>Key point</strong>: Lazy imports defer <em>when</em> a module loads, not <em>what</em> gets
loaded. You cannot selectively load only parts of a module – Python’s import
system doesn’t support partial module execution.</p>
</section>
<section id="what-about-type-annotations-and-type-checking-imports">
<h3><a class="toc-backref" href="#what-about-type-annotations-and-type-checking-imports" role="doc-backlink">What about type annotations and <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> imports?</a></h3>
<p>Lazy imports eliminate the common need for <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> guards. You
can write:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Mapping</span>  <span class="c1"># No runtime cost</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Instead of:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="what-s-the-performance-overhead-of-lazy-imports">
<h3><a class="toc-backref" href="#what-s-the-performance-overhead-of-lazy-imports" role="doc-backlink">What’s the performance overhead of lazy imports?</a></h3>
<p>The overhead is minimal:</p>
<ul class="simple">
<li>Zero overhead after first use thanks to the adaptive interpreter optimizing
the slow path away.</li>
<li>Small one-time cost to create the proxy object.</li>
<li>Reification (first use) has the same cost as a regular import.</li>
<li>No ongoing performance penalty.</li>
</ul>
<p>Benchmarking with the <a class="reference external" href="https://github.com/facebookexperimental/free-threading-benchmarking/blob/main/results/bm-20250922-3.15.0a0-27836e5/bm-20250922-vultr-x86_64-DinoV-lazy_imports-3.15.0a0-27836e5-vs-base.svg">pyperformance suite</a> shows the implementation is
performance neutral when lazy imports are not used.</p>
</section>
<section id="can-i-mix-lazy-and-eager-imports-of-the-same-module">
<h3><a class="toc-backref" href="#can-i-mix-lazy-and-eager-imports-of-the-same-module" role="doc-backlink">Can I mix lazy and eager imports of the same module?</a></h3>
<p>Yes. If module <code class="docutils literal notranslate"><span class="pre">foo</span></code> is imported both lazily and eagerly in the same
program, the eager import takes precedence and both bindings resolve to the
same module object.</p>
</section>
<section id="how-do-i-migrate-existing-code-to-use-lazy-imports">
<h3><a class="toc-backref" href="#how-do-i-migrate-existing-code-to-use-lazy-imports" role="doc-backlink">How do I migrate existing code to use lazy imports?</a></h3>
<p>Migration is incremental:</p>
<ol class="arabic simple">
<li>Identify slow-loading modules using profiling tools.</li>
<li>Add <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword to imports that aren’t needed immediately.</li>
<li>Test that side-effect timing changes don’t break functionality.</li>
<li>Use <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> for compatibility with older Python versions.</li>
</ol>
</section>
<section id="what-about-star-imports-from-module-import">
<h3><a class="toc-backref" href="#what-about-star-imports-from-module-import" role="doc-backlink">What about star imports (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>)?</a></h3>
<p>Wild card (star) imports cannot be lazy - they remain eager. This is
because the set of names being imported cannot be determined without loading
the module. Using the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword with star imports will be a syntax
error. If lazy imports are globally enabled, star imports will still be eager.</p>
</section>
<section id="how-do-lazy-imports-interact-with-import-hooks-and-custom-loaders">
<h3><a class="toc-backref" href="#how-do-lazy-imports-interact-with-import-hooks-and-custom-loaders" role="doc-backlink">How do lazy imports interact with import hooks and custom loaders?</a></h3>
<p>Import hooks and loaders work normally. When a lazy object is first used,
the standard import protocol runs, including any custom hooks or loaders that
were in place at reification time.</p>
</section>
<section id="what-happens-in-multi-threaded-environments">
<h3><a class="toc-backref" href="#what-happens-in-multi-threaded-environments" role="doc-backlink">What happens in multi-threaded environments?</a></h3>
<p>Lazy import reification is thread-safe. Only one thread will perform the
actual import, and the binding is atomically updated. Other threads will see
either the lazy proxy or the final resolved object.</p>
</section>
<section id="can-i-force-reification-of-a-lazy-import-without-using-it">
<h3><a class="toc-backref" href="#can-i-force-reification-of-a-lazy-import-without-using-it" role="doc-backlink">Can I force reification of a lazy import without using it?</a></h3>
<p>Yes, accessing a module’s <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> will reify all lazy objects in that
module. Individual lazy objects can be resolved by calling their <code class="docutils literal notranslate"><span class="pre">get()</span></code>
method.</p>
</section>
<section id="what-s-the-difference-between-globals-and-mod-dict-for-lazy-imports">
<h3><a class="toc-backref" href="#what-s-the-difference-between-globals-and-mod-dict-for-lazy-imports" role="doc-backlink">What’s the difference between <code class="docutils literal notranslate"><span class="pre">globals()</span></code> and <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> for lazy imports?</a></h3>
<p>Calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> returns the module’s dictionary without reifying lazy
imports – you’ll see lazy proxy objects when accessing them through the
returned dictionary. However, accessing <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> from external code
reifies all lazy imports in that module first. This design ensures:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># In your module:</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="n">g</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]))</span>  <span class="c1"># &lt;class &#39;lazy_import&#39;&gt; - your problem</span>

<span class="c1"># From external code:</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">mod</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;your_module&#39;</span><span class="p">]</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]))</span>  <span class="c1"># &lt;class &#39;module&#39;&gt; - reified for external access</span>
</pre></div>
</div>
<p>This distinction means adding lazy imports and calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is your
responsibility to manage, while external code accessing <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code>
always sees fully loaded modules.</p>
</section>
<section id="why-not-use-importlib-util-lazyloader-instead">
<h3><a class="toc-backref" href="#why-not-use-importlib-util-lazyloader-instead" role="doc-backlink">Why not use <code class="docutils literal notranslate"><span class="pre">importlib.util.LazyLoader</span></code> instead?</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> has significant limitations:</p>
<ul class="simple">
<li>Requires verbose setup code for each lazy import.</li>
<li>Doesn’t work well with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> statements.</li>
<li>Less clear and standard than dedicated syntax.</li>
</ul>
</section>
<section id="will-this-break-tools-like-isort-or-black">
<h3><a class="toc-backref" href="#will-this-break-tools-like-isort-or-black" role="doc-backlink">Will this break tools like <code class="docutils literal notranslate"><span class="pre">isort</span></code> or <code class="docutils literal notranslate"><span class="pre">black</span></code>?</a></h3>
<p>Linters, formatters, and other tools will need updates to recognize
the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword, but the changes should be minimal since the import
structure remains the same. The keyword appears at the beginning,
making it easy to parse.</p>
</section>
<section id="how-do-i-know-if-a-library-is-compatible-with-lazy-imports">
<h3><a class="toc-backref" href="#how-do-i-know-if-a-library-is-compatible-with-lazy-imports" role="doc-backlink">How do I know if a library is compatible with lazy imports?</a></h3>
<p>Most libraries should work fine with lazy imports. Libraries that might
have issues:</p>
<ul class="simple">
<li>Those with essential import-time side effects (registration,
monkey-patching).</li>
<li>Those that expect specific import ordering.</li>
<li>Those that modify global state during import.</li>
</ul>
<p>When in doubt, test lazy imports with your specific use cases.</p>
</section>
<section id="what-happens-if-i-globally-enable-lazy-imports-mode-and-a-library-doesn-t-work-correctly">
<h3><a class="toc-backref" href="#what-happens-if-i-globally-enable-lazy-imports-mode-and-a-library-doesn-t-work-correctly" role="doc-backlink">What happens if I globally enable lazy imports mode and a library doesn’t work correctly?</a></h3>
<p><em>Note: This is an advanced feature.</em> You can use the lazy imports filter to
exclude specific modules that are known to have problematic side effects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="k">def</span><span class="w"> </span><span class="nf">my_filter</span><span class="p">(</span><span class="n">importer</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fromlist</span><span class="p">):</span>
    <span class="c1"># Don&#39;t lazily import modules known to have side effects</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;problematic_module&#39;</span><span class="p">,</span> <span class="s1">&#39;another_module&#39;</span><span class="p">}:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Import eagerly</span>
    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Allow lazy import</span>

<span class="n">sys</span><span class="o">.</span><span class="n">set_lazy_imports_filter</span><span class="p">(</span><span class="n">my_filter</span><span class="p">)</span>
</pre></div>
</div>
<p>The filter function receives the importer module name, the module being
imported, and the fromlist (if using <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code>). Returning <code class="docutils literal notranslate"><span class="pre">False</span></code>
forces an eager import.</p>
<p>Alternatively, set the global mode to <code class="docutils literal notranslate"><span class="pre">&quot;disabled&quot;</span></code> via <code class="docutils literal notranslate"><span class="pre">-X</span>
<span class="pre">lazy_imports=disabled</span></code> to turn off all lazy imports for debugging.</p>
</section>
<section id="can-i-use-lazy-imports-inside-functions">
<h3><a class="toc-backref" href="#can-i-use-lazy-imports-inside-functions" role="doc-backlink">Can I use lazy imports inside functions?</a></h3>
<p>No, the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword is only allowed at module level. For
function-level lazy loading, use traditional inline imports or move the import
to module level with <code class="docutils literal notranslate"><span class="pre">lazy</span></code>.</p>
</section>
<section id="what-about-forwards-compatibility-with-older-python-versions">
<h3><a class="toc-backref" href="#what-about-forwards-compatibility-with-older-python-versions" role="doc-backlink">What about forwards compatibility with older Python versions?</a></h3>
<p>Use the <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> global for compatibility:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Works on Python 3.15+ as lazy, eager on older versions</span>
<span class="n">__lazy_modules__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;expensive_module&#39;</span><span class="p">,</span> <span class="s1">&#39;expensive_module_2&#39;</span><span class="p">]</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">expensive_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">expensive_module_2</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyClass</span>
</pre></div>
</div>
<p>The <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> attribute is a list of module name strings. When
an import statement is executed, Python checks if the module name being
imported appears in <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code>. If it does, the import is
treated as if it had the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword (becoming <em>potentially lazy</em>). On
Python versions before 3.15 that don’t support lazy imports, the
<code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code> attribute is simply ignored and imports proceed
eagerly as normal.</p>
<p>This provides a migration path until you can rely on the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword. For
maximum predictability, it’s recommended to define <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code>
once, before any imports. But as it is checked on each import, it can be
modified between <code class="docutils literal notranslate"><span class="pre">import</span></code> statements.</p>
</section>
<section id="how-do-explicit-lazy-imports-interact-with-pep-649-and-pep-749">
<h3><a class="toc-backref" href="#how-do-explicit-lazy-imports-interact-with-pep-649-and-pep-749" role="doc-backlink">How do explicit lazy imports interact with PEP 649 and PEP 749?</a></h3>
<p>Python 3.14 implemented deferred evaluation of annotations,
as specified by <a class="pep reference internal" href="../pep-0649/" title="PEP 649 – Deferred Evaluation Of Annotations Using Descriptors">PEP 649</a> and <a class="pep reference internal" href="../pep-0749/" title="PEP 749 – Implementing PEP 649">PEP 749</a>.
If an annotation is not stringified, it is an expression that is evaluated
at a later time. It will only be resolved if the annotation is accessed. In
the example below, the <code class="docutils literal notranslate"><span class="pre">fake_typing</span></code> module is only loaded when the user
inspects the <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> dictionary. The <code class="docutils literal notranslate"><span class="pre">fake_typing</span></code> module would
also be loaded if the user uses <code class="docutils literal notranslate"><span class="pre">annotationlib.get_annotations()</span></code> or
<code class="docutils literal notranslate"><span class="pre">getattr</span></code> to access the annotations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">from</span><span class="w"> </span><span class="nn">fake_typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">MyFakeType</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">MyFakeType</span><span class="p">):</span>
  <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">)</span>  <span class="c1"># Triggers loading the fake_typing module</span>
</pre></div>
</div>
</section>
<section id="how-do-lazy-imports-interact-with-dir-getattr-and-module-introspection">
<h3><a class="toc-backref" href="#how-do-lazy-imports-interact-with-dir-getattr-and-module-introspection" role="doc-backlink">How do lazy imports interact with <code class="docutils literal notranslate"><span class="pre">dir()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, and module introspection?</a></h3>
<p>Accessing lazy imports through normal attribute access or <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>
will trigger reification. Calling <code class="docutils literal notranslate"><span class="pre">dir()</span></code> on a module will reify all lazy
imports in that module to ensure the directory listing is complete. This is
similar to accessing <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="c1"># Before any access</span>
<span class="c1"># json not in sys.modules</span>

<span class="c1"># Any of these trigger reification:</span>
<span class="n">dumps_func</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span>
<span class="n">dumps_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">json</span><span class="p">,</span> <span class="s1">&#39;dumps&#39;</span><span class="p">)</span>
<span class="nb">dir</span><span class="p">(</span><span class="n">json</span><span class="p">)</span>
<span class="c1"># Now json is in sys.modules</span>
</pre></div>
</div>
</section>
<section id="do-lazy-imports-work-with-circular-imports">
<h3><a class="toc-backref" href="#do-lazy-imports-work-with-circular-imports" role="doc-backlink">Do lazy imports work with circular imports?</a></h3>
<p>Lazy imports don’t automatically solve circular import problems. If two
modules have a circular dependency, making the imports lazy might help <strong>only
if</strong> the circular reference isn’t accessed during module initialization.
However, if either module accesses the other during import time, you’ll still
get an error.</p>
<p><strong>Example that works</strong> (deferred access in functions):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># user_model.py</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">post_model</span>

<span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_posts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># OK - post_model accessed inside function, not during import</span>
        <span class="k">return</span> <span class="n">post_model</span><span class="o">.</span><span class="n">Post</span><span class="o">.</span><span class="n">get_by_user</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="c1"># post_model.py</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">user_model</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Post</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_by_user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Posts by </span><span class="si">{</span><span class="n">username</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>This works because neither module accesses the other at module level – the
access happens later when <code class="docutils literal notranslate"><span class="pre">get_posts()</span></code> is called.</p>
<p><strong>Example that fails</strong> (access during import):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># module_a.py</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">module_b</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">module_b</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>  <span class="c1"># Error! Accessing during import</span>

<span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;A&quot;</span>

<span class="c1"># module_b.py</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">module_a</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">module_a</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>  <span class="c1"># Circular dependency error here</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_value</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;B&quot;</span>
</pre></div>
</div>
<p>This fails because <code class="docutils literal notranslate"><span class="pre">module_a</span></code> tries to access <code class="docutils literal notranslate"><span class="pre">module_b</span></code> at import time,
which then tries to access <code class="docutils literal notranslate"><span class="pre">module_a</span></code> before it’s fully initialized.</p>
<p>The best practice is still to avoid circular imports in your code design.</p>
</section>
<section id="will-lazy-imports-affect-the-performance-of-my-hot-paths">
<h3><a class="toc-backref" href="#will-lazy-imports-affect-the-performance-of-my-hot-paths" role="doc-backlink">Will lazy imports affect the performance of my hot paths?</a></h3>
<p>After first use, lazy imports have <strong>zero overhead</strong> thanks to the adaptive
interpreter. The interpreter specializes the bytecode (e.g., <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL</span></code>
becomes <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code>) which eliminates the lazy check on subsequent
accesses. This means once a lazy import is reified, accessing it is just as
fast as a normal import.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="k">def</span><span class="w"> </span><span class="nf">use_json</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;test&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>

<span class="c1"># First call triggers reification</span>
<span class="n">use_json</span><span class="p">()</span>

<span class="c1"># After 2-3 calls, bytecode is specialized</span>
<span class="n">use_json</span><span class="p">()</span>
<span class="n">use_json</span><span class="p">()</span>
</pre></div>
</div>
<p>You can observe the specialization using <code class="docutils literal notranslate"><span class="pre">dis.dis(use_json,</span> <span class="pre">adaptive=True)</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>=== Before specialization ===
LOAD_GLOBAL              0 (json)
LOAD_ATTR                2 (dumps)

=== After 3 calls (specialized) ===
LOAD_GLOBAL_MODULE       0 (json)
LOAD_ATTR_MODULE         2 (dumps)
</pre></div>
</div>
<p>The specialized <code class="docutils literal notranslate"><span class="pre">LOAD_GLOBAL_MODULE</span></code> and <code class="docutils literal notranslate"><span class="pre">LOAD_ATTR_MODULE</span></code> instructions
are optimized fast paths with no overhead for checking lazy imports.</p>
</section>
<section id="what-about-sys-modules-when-does-a-lazy-import-appear-there">
<h3><a class="toc-backref" href="#what-about-sys-modules-when-does-a-lazy-import-appear-there" role="doc-backlink">What about <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>? When does a lazy import appear there?</a></h3>
<p>A lazily imported module does <strong>not</strong> appear in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> until it’s
reified (first used). Once reified, it appears in <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> just like
any eager import.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">lazy</span> <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># False</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>  <span class="c1"># First use</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;json&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>  <span class="c1"># True</span>
</pre></div>
</div>
</section>
<section id="does-lazy-from-future-import-feature-work">
<h3><a class="toc-backref" href="#does-lazy-from-future-import-feature-work" role="doc-backlink">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">feature</span></code> work?</a></h3>
<p>No, future imports can’t be lazy because they’re parser/compiler directives.
It’s technically possible for the runtime behavior to be lazy but there’s no
real value in it.</p>
</section>
<section id="why-you-chose-lazy-as-the-keyword-name">
<h3><a class="toc-backref" href="#why-you-chose-lazy-as-the-keyword-name" role="doc-backlink">Why you chose <code class="docutils literal notranslate"><span class="pre">lazy</span></code> as the keyword name?</a></h3>
<p>Not “why”… memorize! :)</p>
</section>
</section>
<section id="alternate-implementation-ideas">
<h2><a class="toc-backref" href="#alternate-implementation-ideas" role="doc-backlink">Alternate Implementation Ideas</a></h2>
<p>Here are some alternative design decisions that were considered during the
development of this PEP. While the current proposal represents what we believe
to be the best balance of simplicity, performance, and maintainability, these
alternatives offer different trade-offs that may be valuable for implementers
to consider or for future refinements.</p>
<section id="leveraging-a-subclass-of-dict">
<h3><a class="toc-backref" href="#leveraging-a-subclass-of-dict" role="doc-backlink">Leveraging a subclass of dict</a></h3>
<p>Instead of updating the internal dict object to directly add the fields needed
to support lazy imports, we could create a subclass of the dict object to be
used specifically for Lazy Import enablement. This would still be a leaky
abstraction though - methods can be called directly such as
<code class="docutils literal notranslate"><span class="pre">dict.__getitem__</span></code> and it would impact the performance of globals lookup in
the interpreter.</p>
</section>
<section id="alternate-keyword-names">
<h3><a class="toc-backref" href="#alternate-keyword-names" role="doc-backlink">Alternate keyword names</a></h3>
<p>For this PEP, we decided to propose <code class="docutils literal notranslate"><span class="pre">lazy</span></code> for the explicit keyword as it
felt the most familar to those already focused on optimizing import overhead.
We also considered a variety of other options to support explicit lazy
imports. The most compelling alternates were <code class="docutils literal notranslate"><span class="pre">defer</span></code> and <code class="docutils literal notranslate"><span class="pre">delay</span></code>.</p>
</section>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="making-the-new-behavior-the-default">
<h3><a class="toc-backref" href="#making-the-new-behavior-the-default" role="doc-backlink">Making the new behavior the default</a></h3>
<p>Changing <code class="docutils literal notranslate"><span class="pre">import</span></code> to be lazy by default is outside of the scope of this PEP.
From the discussion on <a class="pep reference internal" href="../pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a> it is clear that this is a fairly
contentious idea, although perhaps once we have wide-spread use of lazy
imports this can be reconsidered.</p>
</section>
<section id="modification-of-the-dict-object">
<h3><a class="toc-backref" href="#modification-of-the-dict-object" role="doc-backlink">Modification of the dict object</a></h3>
<p>The initial PEP for lazy imports (PEP 690) relied heavily on the modification
of the internal dict object to support lazy imports. We recognize that this
data structure is highly tuned, heavily used across the codebase, and very
performance sensitive. Because of the importance of this data structure and
the desire to keep the implementation of lazy imports encapsulated from users
who may have no interest in the feature, we’ve decided to invest in an
alternate approach.</p>
<p>The dictionary is the foundational data structure in Python. Every object’s
attributes are stored in a dict, and dicts are used throughout the runtime for
namespaces, keyword arguments, and more. Adding any kind of hook or special
behavior to dicts to support lazy imports would:</p>
<ol class="arabic simple">
<li>Prevent critical interpreter optimizations including future JIT
compilation.</li>
<li>Add complexity to a data structure that must remain simple and fast.</li>
<li>Affect every part of Python, not just import behavior.</li>
<li>Violate separation of concerns – the hash table shouldn’t know about the
import system.</li>
</ol>
<p>Past decisions that violated this principle of keeping core abstractions clean
have caused significant pain in the CPython ecosystem, making optimization
difficult and introducing subtle bugs.</p>
</section>
<section id="making-lazy-imports-find-the-module-without-loading-it">
<h3><a class="toc-backref" href="#making-lazy-imports-find-the-module-without-loading-it" role="doc-backlink">Making <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports find the module without loading it</a></h3>
<p>The Python <code class="docutils literal notranslate"><span class="pre">import</span></code> machinery separates out finding a module and loading
it, and the lazy import implementation could technically defer only the
loading part. However:</p>
<ul class="simple">
<li>Finding the module does not guarantee the import will succeed, nor even
that it will not raise ImportError.</li>
<li>Finding modules in packages requires that those packages are loaded, so
it would only help with lazy loading one level of a package hierarchy.</li>
<li>Since “finding” attributes in modules <em>requires</em> loading them, this would
create a hard to explain difference between
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">module</span></code> and <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">function</span></code>.</li>
<li>A significant part of the performance win is skipping the finding part
(which may involve filesystem searches and consulting multiple importers
and meta-importers).</li>
</ul>
</section>
<section id="placing-the-lazy-keyword-in-the-middle-of-from-imports">
<h3><a class="toc-backref" href="#placing-the-lazy-keyword-in-the-middle-of-from-imports" role="doc-backlink">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword in the middle of from imports</a></h3>
<p>While we found <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo</span> <span class="pre">lazy</span> <span class="pre">import</span> <span class="pre">bar</span></code> to be a really intuitive placement
for the new explicit syntax, we quickly learned that placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code>
keyword here is already syntactically allowed in Python. This is because
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">lazy</span> <span class="pre">import</span> <span class="pre">bar</span></code> is legal syntax (because whitespace does not
matter.)</p>
</section>
<section id="placing-the-lazy-keyword-at-the-end-of-import-statements">
<h3><a class="toc-backref" href="#placing-the-lazy-keyword-at-the-end-of-import-statements" role="doc-backlink">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword at the end of import statements</a></h3>
<p>We discussed appending lazy to the end of import statements like such <code class="docutils literal notranslate"><span class="pre">import</span>
<span class="pre">foo</span> <span class="pre">lazy</span></code> or <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo</span> <span class="pre">import</span> <span class="pre">bar,</span> <span class="pre">baz</span> <span class="pre">lazy</span></code> but ultimately decided that
this approach provided less clarity. For example, if multiple modules are
imported in a single statement, it is unclear if the lazy binding applies to
all of the imported objects or just a subset of the items.</p>
</section>
<section id="adding-an-explicit-eager-keyword">
<h3><a class="toc-backref" href="#adding-an-explicit-eager-keyword" role="doc-backlink">Adding an explicit <code class="docutils literal notranslate"><span class="pre">eager</span></code> keyword</a></h3>
<p>Since we’re not changing the default behavior, and we don’t want to
encourage use of the global flags, it’s too early to consider adding
superfluous syntax for the common, default case. It would create too much
confusion about what the default is, or when the <code class="docutils literal notranslate"><span class="pre">eager</span></code> keyword would be
necessary, or whether it affects lazy imports <em>in</em> the explicitly eagerly
imported module.</p>
</section>
<section id="using-a-context-manager-instead-of-a-new-soft-keyword">
<h3><a class="toc-backref" href="#using-a-context-manager-instead-of-a-new-soft-keyword" role="doc-backlink">Using a context manager instead of a new soft keyword</a></h3>
<p>A backward compatible syntax, for example in the form of a context manager,
has been proposed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">lazy_imports</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
</pre></div>
</div>
<p>This would replace the need for <code class="xref py py-data docutils literal notranslate"><span class="pre">__lazy_modules__</span></code>, and allow
libraries to use one of the existing lazy imports implementations in older
Python versions. However, adding magic <code class="docutils literal notranslate"><span class="pre">with</span></code> statements with that kind of
effect would be a signficant change to Python and <code class="docutils literal notranslate"><span class="pre">with</span></code> statements in
general, and it would not be easy to combine with the implementation for
lazy imports in this proposal. Adding standard library support for existing
lazy importers <em>without</em> changes to the implementation amounts to the status
quo, and does not solve the performance and usability issues with those
existing solutions.</p>
</section>
<section id="returning-a-proxy-dict-from-globals">
<h3><a class="toc-backref" href="#returning-a-proxy-dict-from-globals" role="doc-backlink">Returning a proxy dict from <code class="docutils literal notranslate"><span class="pre">globals()</span></code></a></h3>
<p>An alternative to reifying on <code class="docutils literal notranslate"><span class="pre">globals()</span></code> or exposing lazy objects would be
to return a proxy dictionary that automatically reifies lazy objects when
they’re accessed through the proxy. This would seemingly give the best of both
worlds: <code class="docutils literal notranslate"><span class="pre">globals()</span></code> returns immediately without reification cost, but
accessing items through the result would automatically resolve lazy imports.</p>
<p>However, this approach is fundamentally incompatible with how <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is
used in practice. Many standard library functions and built-ins expect
<code class="docutils literal notranslate"><span class="pre">globals()</span></code> to return a real <code class="docutils literal notranslate"><span class="pre">dict</span></code> object, not a proxy:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">globals())</span></code> requires a real dict.</li>
<li><code class="docutils literal notranslate"><span class="pre">eval(expr,</span> <span class="pre">globals())</span></code> requires a real dict.</li>
<li>Functions that check <code class="docutils literal notranslate"><span class="pre">type(globals())</span> <span class="pre">is</span> <span class="pre">dict</span></code> would break.</li>
<li>Dictionary methods like <code class="docutils literal notranslate"><span class="pre">.update()</span></code> would need special handling.</li>
<li>Performance would suffer from the indirection on every access.</li>
</ul>
<p>The proxy would need to be so transparent that it would be indistinguishable
from a real dict in almost all cases, which is extremely difficult to achieve
correctly. Any deviation from true dict behavior would be a source of subtle
bugs.</p>
</section>
<section id="reifying-lazy-imports-when-globals-is-called">
<h3><a class="toc-backref" href="#reifying-lazy-imports-when-globals-is-called" role="doc-backlink">Reifying lazy imports when <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is called</a></h3>
<p>Calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> returns the module’s namespace dictionary without
triggering reification of lazy imports. Accessing lazy objects through the
returned dictionary yields the lazy proxy objects themselves. This is an
intentional design decision for several reasons:</p>
<p><strong>The key distinction</strong>: Adding a lazy import and calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is the
module author’s concern and under their control. However, accessing
<code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> from external code is a different scenario – it crosses
module boundaries and affects someone else’s code. Therefore, <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code>
access reifies all lazy imports to ensure external code sees fully realized
modules, while <code class="docutils literal notranslate"><span class="pre">globals()</span></code> preserves lazy objects for the module’s own
introspection needs.</p>
<p><strong>Technical challenges</strong>: It is impossible to safely reify on-demand when
<code class="docutils literal notranslate"><span class="pre">globals()</span></code> is called because we cannot return a proxy dictionary – this
would break common usages like passing the result to <code class="docutils literal notranslate"><span class="pre">exec()</span></code> or other
built-ins that expect a real dictionary. The only alternative would be to
eagerly reify all lazy imports whenever <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is called, but this
behavior would be surprising and potentially expensive.</p>
<p><strong>Performance concerns</strong>: It is impractical to cache whether a reification
scan has been performed with just the globals dictionary reference, whereas
module attribute access (the primary use case) can efficiently cache
reification state in the module object itself.</p>
<p><strong>Use case rationale</strong>: The chosen design makes sense precisely because of
this distinction: adding a lazy import and calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is your
problem to manage, while having lazy imports visible in <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code>
becomes someone else’s problem. By reifying on <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> access but not on
<code class="docutils literal notranslate"><span class="pre">globals()</span></code>, we ensure external code always sees fully loaded modules while
giving module authors control over their own introspection.</p>
<p>Note that three options were considered:</p>
<ol class="arabic simple">
<li>Calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> or <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> traverses and resolves all lazy
objects before returning.</li>
<li>Calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> or <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> returns the dictionary with lazy
objects present.</li>
<li>Calling <code class="docutils literal notranslate"><span class="pre">globals()</span></code> returns the dictionary with lazy objects, but
<code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> reifies everything.</li>
</ol>
<p>We chose the third option because it properly delineates responsibility: if
you add lazy imports to your module and call <code class="docutils literal notranslate"><span class="pre">globals()</span></code>, you’re responsible
for handling the lazy objects. But external code accessing your module’s
<code class="docutils literal notranslate"><span class="pre">__dict__</span></code> shouldn’t need to know about your lazy imports – it gets fully
resolved modules.</p>
</section>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>We would like to thank Paul Ganssle, Yury Selivanov, Łukasz Langa, Lysandros
Nikolaou, Pradyun Gedam, Mark Shannon, Hana Joo and the Python Google team,
the Python team(s) &#64; Meta, the Python &#64; HRT team, the Bloomberg Python team,
the Scientific Python community, everyone who participated in the initial
discussion of <a class="pep reference internal" href="../pep-0690/" title="PEP 690 – Lazy Imports">PEP 690</a>, and many others who provided valuable feedback and
insights that helped shape this PEP.</p>
</section>
<section id="footnotes">
<h2><a class="toc-backref" href="#footnotes" role="doc-backlink">Footnotes</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="doc-footnote">
<dt class="label" id="f1">[<a href="#id1">1</a>]</dt>
<dd>Furthermore, there’s also external tooling, in the form of
<a class="reference external" href="https://pypi.org/project/flake8-type-checking/">flake8-type-checking</a>,
because it is common for developers to mislocate imports and accidentally
introduce a runtime dependency on an import only imported in such a block.
Ironically, the static type checker is of no help in these circumstances.</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0810.rst">https://github.com/python/peps/blob/main/peps/pep-0810.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0810.rst">2025-10-04 16:24:51 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#other-design-decisions">Other design decisions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#grammar">Grammar</a><ul>
<li><a class="reference internal" href="#syntax-restrictions">Syntax restrictions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#semantics">Semantics</a></li>
<li><a class="reference internal" href="#lazy-import-mechanism">Lazy import mechanism</a></li>
<li><a class="reference internal" href="#reification">Reification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a><ul>
<li><a class="reference internal" href="#bytecode-and-adaptive-specialization">Bytecode and adaptive specialization</a></li>
<li><a class="reference internal" href="#lazy-imports-filter">Lazy imports filter</a></li>
<li><a class="reference internal" href="#global-lazy-imports-control">Global lazy imports control</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#unchanged-semantics">Unchanged semantics</a></li>
<li><a class="reference internal" href="#observable-behavioral-shifts-opt-in-only">Observable behavioral shifts (opt-in only)</a></li>
<li><a class="reference internal" href="#thread-safety-and-reification">Thread-safety and reification</a></li>
<li><a class="reference internal" href="#typing-and-tools">Typing and tools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#faq">FAQ</a><ul>
<li><a class="reference internal" href="#how-does-this-differ-from-the-rejected-pep-690">How does this differ from the rejected PEP 690?</a></li>
<li><a class="reference internal" href="#what-happens-when-lazy-imports-encounter-errors">What happens when lazy imports encounter errors?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-affect-modules-with-import-time-side-effects">How do lazy imports affect modules with import-time side effects?</a></li>
<li><a class="reference internal" href="#can-i-use-lazy-imports-with-from-import-statements">Can I use lazy imports with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> statements?</a></li>
<li><a class="reference internal" href="#does-lazy-from-module-import-class-load-the-entire-module-or-just-the-class">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Class</span></code> load the entire module or just the class?</a></li>
<li><a class="reference internal" href="#what-about-type-annotations-and-type-checking-imports">What about type annotations and <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> imports?</a></li>
<li><a class="reference internal" href="#what-s-the-performance-overhead-of-lazy-imports">What’s the performance overhead of lazy imports?</a></li>
<li><a class="reference internal" href="#can-i-mix-lazy-and-eager-imports-of-the-same-module">Can I mix lazy and eager imports of the same module?</a></li>
<li><a class="reference internal" href="#how-do-i-migrate-existing-code-to-use-lazy-imports">How do I migrate existing code to use lazy imports?</a></li>
<li><a class="reference internal" href="#what-about-star-imports-from-module-import">What about star imports (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>)?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-interact-with-import-hooks-and-custom-loaders">How do lazy imports interact with import hooks and custom loaders?</a></li>
<li><a class="reference internal" href="#what-happens-in-multi-threaded-environments">What happens in multi-threaded environments?</a></li>
<li><a class="reference internal" href="#can-i-force-reification-of-a-lazy-import-without-using-it">Can I force reification of a lazy import without using it?</a></li>
<li><a class="reference internal" href="#what-s-the-difference-between-globals-and-mod-dict-for-lazy-imports">What’s the difference between <code class="docutils literal notranslate"><span class="pre">globals()</span></code> and <code class="docutils literal notranslate"><span class="pre">mod.__dict__</span></code> for lazy imports?</a></li>
<li><a class="reference internal" href="#why-not-use-importlib-util-lazyloader-instead">Why not use <code class="docutils literal notranslate"><span class="pre">importlib.util.LazyLoader</span></code> instead?</a></li>
<li><a class="reference internal" href="#will-this-break-tools-like-isort-or-black">Will this break tools like <code class="docutils literal notranslate"><span class="pre">isort</span></code> or <code class="docutils literal notranslate"><span class="pre">black</span></code>?</a></li>
<li><a class="reference internal" href="#how-do-i-know-if-a-library-is-compatible-with-lazy-imports">How do I know if a library is compatible with lazy imports?</a></li>
<li><a class="reference internal" href="#what-happens-if-i-globally-enable-lazy-imports-mode-and-a-library-doesn-t-work-correctly">What happens if I globally enable lazy imports mode and a library doesn’t work correctly?</a></li>
<li><a class="reference internal" href="#can-i-use-lazy-imports-inside-functions">Can I use lazy imports inside functions?</a></li>
<li><a class="reference internal" href="#what-about-forwards-compatibility-with-older-python-versions">What about forwards compatibility with older Python versions?</a></li>
<li><a class="reference internal" href="#how-do-explicit-lazy-imports-interact-with-pep-649-and-pep-749">How do explicit lazy imports interact with PEP 649 and PEP 749?</a></li>
<li><a class="reference internal" href="#how-do-lazy-imports-interact-with-dir-getattr-and-module-introspection">How do lazy imports interact with <code class="docutils literal notranslate"><span class="pre">dir()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, and module introspection?</a></li>
<li><a class="reference internal" href="#do-lazy-imports-work-with-circular-imports">Do lazy imports work with circular imports?</a></li>
<li><a class="reference internal" href="#will-lazy-imports-affect-the-performance-of-my-hot-paths">Will lazy imports affect the performance of my hot paths?</a></li>
<li><a class="reference internal" href="#what-about-sys-modules-when-does-a-lazy-import-appear-there">What about <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>? When does a lazy import appear there?</a></li>
<li><a class="reference internal" href="#does-lazy-from-future-import-feature-work">Does <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">feature</span></code> work?</a></li>
<li><a class="reference internal" href="#why-you-chose-lazy-as-the-keyword-name">Why you chose <code class="docutils literal notranslate"><span class="pre">lazy</span></code> as the keyword name?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-implementation-ideas">Alternate Implementation Ideas</a><ul>
<li><a class="reference internal" href="#leveraging-a-subclass-of-dict">Leveraging a subclass of dict</a></li>
<li><a class="reference internal" href="#alternate-keyword-names">Alternate keyword names</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#making-the-new-behavior-the-default">Making the new behavior the default</a></li>
<li><a class="reference internal" href="#modification-of-the-dict-object">Modification of the dict object</a></li>
<li><a class="reference internal" href="#making-lazy-imports-find-the-module-without-loading-it">Making <code class="docutils literal notranslate"><span class="pre">lazy</span></code> imports find the module without loading it</a></li>
<li><a class="reference internal" href="#placing-the-lazy-keyword-in-the-middle-of-from-imports">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword in the middle of from imports</a></li>
<li><a class="reference internal" href="#placing-the-lazy-keyword-at-the-end-of-import-statements">Placing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> keyword at the end of import statements</a></li>
<li><a class="reference internal" href="#adding-an-explicit-eager-keyword">Adding an explicit <code class="docutils literal notranslate"><span class="pre">eager</span></code> keyword</a></li>
<li><a class="reference internal" href="#using-a-context-manager-instead-of-a-new-soft-keyword">Using a context manager instead of a new soft keyword</a></li>
<li><a class="reference internal" href="#returning-a-proxy-dict-from-globals">Returning a proxy dict from <code class="docutils literal notranslate"><span class="pre">globals()</span></code></a></li>
<li><a class="reference internal" href="#reifying-lazy-imports-when-globals-is-called">Reifying lazy imports when <code class="docutils literal notranslate"><span class="pre">globals()</span></code> is called</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0810.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>